'use strict'

const os = require('os')
const figures = require('figures')
const chalk = require('chalk')
const keypress = require('keypress')
const ansiEscapes = require('ansi-escapes')
const stripAnsi = require('strip-ansi')
const minimist = require('minimist')
const emoji = require('node-emoji')
const spawn = require('child-process-ext/spawn')
const fetchLatestVersion = require('latest-version')
const isInstalledGlobally = require('is-installed-globally')
const { gt: versionGreaterThan, satisfies: versionSatisfies } = require('semver')

const { version: currentVersion } = require('../../package.json')
const commands = require('../commands')

class CLI {
  constructor() {
    this._initStyles()
    this._initIcons()
    this._initTips()
    this._initSuggestions()

    this._viewType = null
    this._viewMessage = null

    this.inputValue = ''
    this.allowedInputCharacter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_. '

    this.options = {}
    this._commandsHistory = []
  }

  async prompt(question, options = {}) {
    this._isPromptActive = true

    if (options.default) {
      this.inputValue = options.default
    }

    this.viewInput(question)

    const sleep = async (ms) => new Promise((res) => setTimeout(res, ms))

    while (!this._promptResponse) await sleep(50)

    const promptResponse = this._promptResponse

    this.logInfo(`You've entered ${this.styles.bold(promptResponse)}.`)

    this._promptResponse = null
    this._isPromptActive = false

    return promptResponse
  }

  async promptServiceName(defaultServiceName = null) {
    this.logInfo('Please enter a name for your app.')
    const specifiedServiceName = await this.prompt('type an app name', { default: defaultServiceName })

    if (!specifiedServiceName.match(/^[a-z0-9-]+$/)) {
      this.logError('App name must consist only of lowercase characters and hyphens. Please try again.')
      return await this.promptServiceName()
    }

    return specifiedServiceName
  }

  async confirm() {
    const selectItems = ['yes', 'no']
    const answer = await this.select(selectItems)

    if (answer === selectItems[0]) {
      return true
    }

    if (answer === selectItems[1]) {
      return false
    }

    return false
  }

  async run(inputValue) {
    if (!this.isShellActive) {
      this.viewSpinner(`Starting`)
      this._hideCursor()
      this._logLogo()
      this._watchKeyboard()
      await this._autoUpdate()
    }

    this._parseCommand(inputValue)

    try {
      const nonShellCommands = ['clone']

      if (this.isShellActive && nonShellCommands.includes(this.command)) {
        throw new Error(`Command "${this.command}" is currently not supported in the shell`)
      }

      if (!commands[this.command]) {
        throw new Error(`Command "${this.command}" is not a valid command`)
      }

      await commands[this.command](this)

      if (this.autoRunCommand) {
        await commands[this.autoRunCommand](this)
        this.autoRunCommand = null
      }
    } catch (error) {
      this.logError(error.message)
    }

    if (this.isShellActive) {
      return this.viewInput()
    }

    return this._stop()
  }

  viewInput(viewMessage = this._getTip()) {
    clearInterval(this._timerInterval)
    clearInterval(this._spinnerInterval)
    this.switchView({ viewType: 'input', viewMessage })
  }

  viewSpinner(viewMessage = 'Loading', { timer = false } = {}) {
    if (!process.stdin.isTTY) {
      console.log(viewMessage)
      return
    }

    clearInterval(this._spinnerInterval)
    clearInterval(this._timerInterval)

    if (timer) {
      this.timer = 0
      this._timerInterval = setInterval(() => (this.timer = +this.timer + 1), 1000)
    }

    this._spinnerFrequency = 40
    this._spinnerFrames = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']
    this._spinnerFrameIndex = 0
    this._spinnerInterval = setInterval(() => this._updateSpinner(viewMessage, { timer }), this._spinnerFrequency)
  }

  viewTimer(viewMessage) {
    clearInterval(this._timerInterval)
    clearInterval(this._spinnerInterval)

    this.timer = 0

    this._timerInterval = setInterval(() => {
      this.timer = +this.timer + 1
      this.switchView({ viewType: 'timer', viewMessage })
    }, 1000)
    this.switchView({ viewType: 'timer', viewMessage })
  }

  async select(selectItems = [], selectedItemIndex = 0) {
    clearInterval(this._timerInterval)
    clearInterval(this._spinnerInterval)

    this._selectItems = selectItems
    this._selectedItemIndex = selectedItemIndex

    if (this._selectItems.length === 1) {
      this._selectedItem = this._selectItems[0]
      return this._selectedItem
    }

    this.switchView({ viewType: 'select' })

    const sleep = async (ms) => new Promise((res) => setTimeout(res, ms))

    while (!this._selectedItem) await sleep(50)

    const selectedItem = this._selectedItem

    if (typeof selectedItem === 'object') {
      this.logInfo(`You've selected ${this.styles.bold(selectedItem.title)}.`)
    } else {
      this.logInfo(`You've selected ${this.styles.bold(selectedItem)}.`)
    }

    this._selectedItem = null
    this._selectedItemIndex = null
    this._selectItems = []

    return selectedItem
  }

  async selectOrg(userInstance) {
    this.viewSpinner('Loading')
    let orgName
    const orgsList = (await userInstance.listOrgs()).map((org) => org.orgName)

    if (orgsList.length > 1) {
      this.logInfo('Please select an organization to proceed.')
      orgName = await this.select(orgsList)
    } else {
      orgName = orgsList[0]
    }

    return orgName
  }

  async selectService(orgInstance) {
    let serviceName
    this.viewSpinner('Loading')
    const servicesList = (await orgInstance.listServicesWithInstances()).map((service) => service.serviceName)

    if (servicesList.length > 1) {
      this.logQuestion('Which app do you want to clone?')
      serviceName = await this.select(servicesList)
    } else {
      serviceName = servicesList[0]
    }

    return serviceName
  }

  viewMessage(viewMessage) {
    this.switchView({ viewMessage })
  }

  viewType(viewType) {
    this.switchView({ viewType })
  }

  switchView({ viewType, viewMessage }) {
    if (viewType) this._viewType = viewType
    if (viewMessage) this._viewMessage = viewMessage
    return this._view()
  }

  logSuccess(msg, indent = 0) {
    this.log(`${this.icons.tick} ${msg}`, indent)
  }

  logError(msg, indent = 0) {
    this.log(`${this.icons.cross} ${this.styles.red(msg)}`, indent)
  }

  logInfo(msg, indent = 0) {
    this.log(`${this.icons.info} ${msg}`, indent)
  }

  logWarning(msg, indent = 0) {
    this.log(`${this.icons.warning} ${msg}`, indent)
  }

  logQuestion(msg, indent = 0) {
    this.log(`${this.icons.question} ${msg}`, indent)
  }

  logUrl(url, indent = 0) {
    this.log(`${this.icons.arrow} ${url}`, indent)
  }

  logTime(msg, indent = 0) {
    this.log(`${this.styles.dim(`${new Date(Date.now()).toLocaleTimeString()} ${this.icons.line}`)} ${msg}`, indent)
  }

  logActivation(orgName) {
    this.logInfo(`Your org "${orgName}" is not activated for Serverless Cloud.`)
    this.logInfo('Exclusive access code is required to enable Serverless Cloud.')
    this.logInfo('If you don’t have a code, please sign up on the dashboard. ')
    this.logUrl('https://cloud.serverless.com')
  }

  log(msg = '', indent = 0) {
    this._ensureTopPadding()
    this._eraseCursorLineAndBelow()
    this._log(`${' '.repeat(indent)}${msg}\n`)
    this._view()
  }

  onQuit(fn) {
    this._onQuit = fn
  }

  async quit(quiteMessage = 'Canceled') {
    this.inputValue = ''
    this._clearIntervals()
    this.logError(quiteMessage)
    this._eraseCursorLineAndBelow()

    if (this._onQuit) {
      await this._onQuit()
    }

    this._stop()
  }

  _stop(exitCode = 0) {
    this._clearIntervals()
    process.stdin.pause()

    this._eraseCursorLineAndBelow()
    this._log('\n')
    this._showCursor()

    // todo why do we need to do this???
    process.exit(exitCode)
  }

  _clearIntervals() {
    clearInterval(this._timerInterval)
    clearInterval(this._spinnerInterval)
    clearInterval(this._tipsInterval)
  }

  _parseCommand(inputValue) {
    const minimistInput = inputValue ? inputValue.split(' ') : process.argv.slice(2)
    const minimistOutput = minimist(minimistInput)

    this.command = minimistOutput._[0]
    this.args = minimistOutput._.slice(1)
    this.options = Object.assign({}, this.options, minimistOutput)

    if (this.options.help || this.options.h) this.command = 'help'
    if (this.options.version || this.options.v) this.command = 'version'

    // delete the start command if shell already active
    if (inputValue === 'start') {
      delete commands.start
    }

    const isStartCommand = !inputValue && (!this.command || this.command === 'start')

    if (isStartCommand) {
      this.isShellActive = true
      this.command = 'start'
    }

    delete this.options._
  }

  _logLogo() {
    if (!this._canRenderBolt() || process.env.IS_CHILD_PROCESS) {
      return
    }

    let logo = os.EOL

    logo += 'serverless '

    logo += `${this.icons.bolt}`

    logo += 'cloud'

    if (process.env.SERVERLESS_PLATFORM_STAGE === 'dev') {
      logo += this.styles.grey(' (dev)')
    }

    logo += os.EOL
    this._log(logo)
  }

  _log(msg) {
    process.stdout.write(msg)
  }

  _showCursor() {
    this._log(ansiEscapes.cursorShow)
  }

  _hideCursor() {
    this._log(ansiEscapes.cursorHide)
  }

  _moveCursorLeft() {
    this._log(ansiEscapes.cursorLeft)
  }

  _moveCursorUp(rowCount) {
    this._log(ansiEscapes.cursorUp(rowCount))
  }

  _eraseCursorLineAndBelow() {
    this._log(ansiEscapes.eraseDown)
  }

  _restorCursorPosition(outputString) {
    const startingPosition = this._getRelativeVerticalCursorPosition(outputString)
    this._moveCursorUp(startingPosition)
    this._moveCursorLeft()
  }

  _getRelativeVerticalCursorPosition(outputString) {
    const paddingLinesCount = 1
    let lines = stripAnsi(outputString).split('\n')
    let linesCount = lines.length

    for (const line of lines) {
      const lineWidth = Number(line.length)
      const terminalWidth = Number(process.stdout.columns)
      const brokenLinesCount = Math.floor(lineWidth / terminalWidth)

      linesCount += brokenLinesCount
    }

    const totalLinesCount = paddingLinesCount + linesCount

    return totalLinesCount
  }

  _view() {
    let view = this._getView()

    if (!view) return

    this._eraseCursorLineAndBelow()

    this._log(`\n${view}\n`)

    this._restorCursorPosition(view)
  }

  _getView() {
    if (this._viewType === 'input') {
      return this._getInputView()
    }
    if (this._viewType === 'timer') {
      return this._getTimerView()
    }
    if (this._viewType === 'spinner') {
      return this._getSpinnerView()
    }
    if (this._viewType === 'select') {
      return this._getSelectView()
    }
  }

  _getInputView() {
    let view = ''

    if (this._canRenderBolt()) {
      view += `${this.icons.bolt}`
    }

    view += `${this.icons.pointer} `

    if (this.inputValue !== '') {
      const suggestedCommand = this._suggestCommand()

      if (suggestedCommand && !this._isPromptActive) {
        const suggestedFragment = suggestedCommand.replace(this.inputValue, '')
        return (view += `${this.inputValue}${this.styles.dim(suggestedFragment)}`)
      }

      return (view += `${this.inputValue}▊`)
    }

    return (view += `▊${this.styles.dim(this._viewMessage)}`)
  }

  _getTimerView() {
    return this.styles.grey(`${this.timer}s ${this.icons.pointer} ${this._viewMessage}`)
  }

  _getSpinnerView() {
    return `${this._getSpinnerFrame()} ${this._viewMessage}`
  }

  _getSelectView() {
    if (this._isSelectingLongList()) return this._getLongSelectView()
    return this._getNormalSelectView()
  }

  _isSelectingLongList() {
    const margin = 4

    if (this._selectItems.length >= process.stdout.rows - margin) {
      return true
    }

    return false
  }

  _getNormalSelectView() {
    let view = ''
    this._selectItems.forEach((selectItem, selectItemIndex) => {
      if (selectItemIndex !== this._selectedItemIndex) {
        if (typeof selectItem === 'object') {
          view += `  ${this.styles.grey(`${selectItem.title} - ${selectItem.description}`)}`
        } else {
          view += `  ${this.styles.grey(`${selectItem}`)}`
        }
      } else {
        if (typeof selectItem === 'object') {
          view += `${this.icons.pointer} ${selectItem.title} ${this.styles.grey(`- ${selectItem.description}`)}`
        } else {
          view += `${this.icons.pointer} ${selectItem}`
        }
      }

      const notLastSelectItem = selectItemIndex < this._selectItems.length - 1

      if (notLastSelectItem) {
        view += '\n'
      }
    })

    return view
  }

  _getLongSelectView() {
    let view = ''

    const previousItem = this._selectItems[this._getPreviousItemIndex()]
    const selectedItem = this._selectItems[this._selectedItemIndex]
    const nextItem = this._selectItems[this._getNextItemIndex()]

    if (typeof selectedItem === 'object') {
      view += `  ${this.styles.grey(`${previousItem.title}`)}\n`
      view += `${this.icons.pointer} ${selectedItem.title} ${this.styles.grey(`(${selectedItem.description})`)}\n`
      view += `  ${this.styles.grey(`${nextItem.title}`)}`
    } else {
      view += `  ${this.styles.grey(`${previousItem}`)}\n`
      view += `${this.icons.pointer} ${selectedItem}\n`
      view += `  ${this.styles.grey(`${nextItem}`)}`
    }

    return view
  }

  _getPreviousItemIndex() {
    const isFirstItemSelected = this._selectedItemIndex === 0
    return isFirstItemSelected ? this._selectItems.length - 1 : this._selectedItemIndex - 1
  }

  _getNextItemIndex() {
    const isLastItemSelected = this._selectedItemIndex === this._selectItems.length - 1
    return isLastItemSelected ? 0 : this._selectedItemIndex + 1
  }

  async _autoUpdate() {
    const skipUpdate = process.env.CLOUD_SKIP_UPDATE || process.argv.slice(2).includes('--skip-update')
    const latestVersion = await fetchLatestVersion('@serverless/cloud')

    if (!skipUpdate && versionGreaterThan(latestVersion, currentVersion)) {
      // don't auto update if the latest is a new major version
      if (!versionSatisfies(latestVersion, `^${currentVersion}`)) {
        this.logError(
          `A new major version of the Serverless Cloud CLI is available (v${latestVersion}). You are currently running v${currentVersion}. To proceed, please update your Serverless Cloud CLI to the latest version.`
        )
        return this._stop(1)
      }

      this.viewSpinner(`Updating CLI ${this.styles.dim(`(takes few mins)`)}`)

      if (process.env.IS_CHILD_PROCESS) {
        /*
         * At this point, the cli was just updated, but the environment
         * is still picking up the old version for some reason.
         * Hopefully this never happens, but we gracefully handle this
         * just in case to avoid a never ending recursive update.
         */
        process.exit(1)
      }

      try {
        await spawn('npm', ['install', '@serverless/cloud', isInstalledGlobally ? '--global' : '--save-development'])

        process.stdin.pause()
        this._clearIntervals()

        await spawn(process.argv.shift(), process.argv, {
          cwd: process.cwd(),
          env: { ...process.env, IS_CHILD_PROCESS: true },
          detached: false,
          stdio: 'inherit'
        })

        process.exit()
      } catch (e) {
        this.logError(
          `Servrless Cloud CLI auto update failed. Please manually update the CLI to the latest version to proceed.`
        )
        return this._stop(1)
      }
    }
  }

  _watchKeyboard() {
    keypress(process.stdin)
    process.stdin.on('keypress', async (character, key = {}) => {
      if (this._shouldQuit(key)) {
        return await this.quit()
      }

      if (this._shouldSubmitSelection(key)) {
        return await this._submitSelection()
      }

      if (this._shouldSelectPrevious(key)) {
        return await this._selectPrevious()
      }

      if (this._shouldSelectNext(key)) {
        return await this._selectNext()
      }

      if (this._shouldSubmitPromptResponse(key)) {
        return await this._submitPromptResponse()
      }

      if (this._shouldGetPreviousCommand(key)) {
        return await this._getPreviousCommand()
      }

      if (this._shouldGetNextCommand(key)) {
        return await this._getNextCommand()
      }

      if (this._shouldClearScreen(key)) {
        return this._clearScreen()
      }

      if (this._shouldRunCommand(key)) {
        return await this._runCommand()
      }

      if (this._shouldAutoComplete(key)) {
        return this._autoComplete()
      }

      if (this._shouldDeleteLastWord(key)) {
        return this._deleteLastWord()
      }

      if (this._shouldDeleteLastCharacter(key)) {
        return this._deleteLastCharacter()
      }

      if (this._shouldClearInputValue(key)) {
        return this._clearInputValue()
      }

      if (this._shouldUpdateInputValue(character)) {
        return this._updateInputValue(character)
      }
    })

    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true)
    }

    process.stdin.resume()
  }

  _shouldSubmitPromptResponse(key) {
    return !!(key.name === 'return' && this.inputValue !== '' && this._isPromptActive)
  }

  _shouldSubmitSelection(key) {
    return !!(key.name === 'return' && this._viewType === 'select')
  }

  _shouldRunCommand(key) {
    return !!(key.name === 'return' && this.inputValue !== '' && this._viewType === 'input')
  }

  _shouldAutoComplete(key) {
    return !!((key.name === 'tab' || key.name === 'right') && this.inputValue !== '' && !this._isPromptActive)
  }

  _shouldDeleteLastCharacter(key) {
    return !!(key.name === 'backspace')
  }

  _shouldDeleteLastWord(key) {
    return !!(key.sequence === '\x17' || (key.name === 'backspace' && key.meta))
  }

  _shouldClearInputValue(key) {
    return !!(key.sequence === '\x15')
  }

  _shouldGetPreviousCommand(key) {
    return !!(key.name === 'up')
  }

  _shouldGetNextCommand(key) {
    return !!(key.name === 'down')
  }

  _shouldSelectPrevious(key) {
    return !!(key.name === 'up') && this._viewType === 'select'
  }

  _shouldSelectNext(key) {
    return !!(key.name === 'down') && this._viewType === 'select'
  }

  _shouldClearScreen(key) {
    const inputValue = this.inputValue.trim()

    if (key.name === 'return' && inputValue === 'clear') {
      return true
    }

    return false
  }

  _shouldQuit(key) {
    const inputValue = this.inputValue.trim()

    const quitCommands = ['quit', 'q', 'exit', 'cancel']

    if (key.name === 'return' && quitCommands.includes(inputValue)) {
      return true
    }

    if (key.ctrl && key.name === 'c') {
      return true
    }

    return false
  }

  _shouldUpdateInputValue(character) {
    return !!(this.allowedInputCharacter.includes(character) && this._viewType === 'input')
  }

  async _submitPromptResponse() {
    this._promptResponse = this.inputValue
    this.inputValue = ''
  }

  async _submitSelection() {
    this._selectedItem = this._selectItems[this._selectedItemIndex]
  }

  async _runCommand() {
    this._updateCommandsHistory()
    this._ensureNoCloudRootCommand()

    const inputValue = this.inputValue
    this.inputValue = ''

    this._commandRunningInShell = true
    await this.run(inputValue)
    this._commandRunningInShell = false
  }

  async _autoComplete() {
    const suggestedCommand = this._suggestCommand()

    if (suggestedCommand) {
      this.inputValue = `${suggestedCommand} `
      this.viewInput()
    }
  }

  _suggestCommand() {
    return this._suggestions.find(
      (suggestion) => suggestion.startsWith(this.inputValue) && suggestion !== this.inputValue
    )
  }

  _ensureNoCloudRootCommand() {
    if (this.inputValue.startsWith('cloud ')) {
      this.inputValue = this.inputValue.replace('cloud ', '')
    }
  }

  _updateCommandsHistory() {
    this.inputValue = this.inputValue.trim()
    this._commandsHistory.push(this.inputValue)
    this._commandsHistoryIndex = null
  }

  _getPreviousCommand() {
    if (this._commandsHistory.length === 0) {
      return
    }

    if (!this._commandsHistoryIndex && this._commandsHistoryIndex !== 0) {
      this._commandsHistoryIndex = this._commandsHistory.length - 1
    } else {
      this._commandsHistoryIndex = this._commandsHistoryIndex - 1
    }

    if (!this._commandsHistory[this._commandsHistoryIndex]) {
      this._commandsHistoryIndex = this._commandsHistory.length - 1
    }

    this.inputValue = this._commandsHistory[this._commandsHistoryIndex]
    this.viewInput()
  }

  _getNextCommand() {
    if (this._commandsHistory.length === 0) {
      return
    }

    if (!this._commandsHistoryIndex && this._commandsHistoryIndex !== 0) {
      this._commandsHistoryIndex = 0
    } else {
      this._commandsHistoryIndex = this._commandsHistoryIndex + 1
    }

    if (!this._commandsHistory[this._commandsHistoryIndex]) {
      this._commandsHistoryIndex = 0
    }

    this.inputValue = this._commandsHistory[this._commandsHistoryIndex]
    this.viewInput()
  }

  _selectPrevious() {
    this._selectedItemIndex = this._getPreviousItemIndex()
    this.switchView({ viewType: 'select' })
  }

  _selectNext() {
    this._selectedItemIndex = this._getNextItemIndex()
    this.switchView({ viewType: 'select' })
  }

  _deleteLastCharacter() {
    this.inputValue = this.inputValue.slice(0, -1)
    this.viewInput(this._viewMessage)
  }

  _deleteLastWord() {
    this.inputValue = this.inputValue.trim()
    this.inputValue = this.inputValue.substring(0, this.inputValue.lastIndexOf(' '))

    this.viewInput(this._viewMessage)
  }

  _clearInputValue() {
    this.inputValue = ''
    this.viewInput(this._viewMessage)
  }

  _updateInputValue(character) {
    this.inputValue += character
    this.viewInput(this._viewMessage)
  }

  _clearScreen() {
    this._updateCommandsHistory()
    this._log(ansiEscapes.clearScreen)
    this._logLogo()
    this.loggedTopPadding = false
    this.inputValue = ''
    this.viewInput()
    this._hideCursor()
  }

  _ensureTopPadding() {
    if (!this.loggedTopPadding) {
      this._log('\n')
      this.loggedTopPadding = true
    }
  }

  _updateSpinner(viewMessage, { timer = false } = {}) {
    this._spinnerFrameIndex = ++this._spinnerFrameIndex % this._spinnerFrames.length

    if (timer) {
      viewMessage = `${viewMessage} ${this.styles.grey(`(${this.timer}s)`)}`
    }

    this.switchView({ viewType: 'spinner', viewMessage })
  }

  _getSpinnerFrame() {
    return this.styles.red(this._spinnerFrames[this._spinnerFrameIndex])
  }

  _initSuggestions() {
    this._suggestions = [
      'deploy',
      'deploy dev',
      'promote',
      'promote dev',
      'promote dev prod',
      'share',
      'import',
      'import --overwrite',
      'export',
      'export --overwrite',
      'exit',
      'clear',
      'cancel',
      'login',
      'logout',
      'help',
      'test',
      'url',
      'open',
      'docs',
      'quit',
      'version'
    ]
  }

  _initTips() {
    this._tipsCollection = [
      'type `share` to share your changes',
      'type `test` to test your changes',
      'type `import` to import data from a data.json file',
      'type `export` to export data to a data.json file',
      'type `deploy <stage>` to deploy to a stage',
      'type `export <file-name>` to specify export file name',
      'type `import <file-name>` to specify import file name',
      'type `docs` to open the docs in your browser',
      'type `help` to see the list of available commands',
      'type `quit` to quit the shell',
      'type `clear` to clear the screen',
      'type `url` to view your personal instance url',
      'type `open` to open your app page in the browser',
      'type `promote <from> <to>` to promote between stages'
    ]

    this._tipsFrequency = 5000
    this._tipsCollectionIndex = 0
    this._tipsInterval = setInterval(() => this._updateTip(), this._tipsFrequency)
  }

  _getTip() {
    return this.styles.dim(this._tipsCollection[this._tipsCollectionIndex])
  }

  _updateTip() {
    this._tipsCollectionIndex = ++this._tipsCollectionIndex % this._tipsCollection.length

    // only update the input view if we are already in input view
    // otherwise, other views currently displayed would disapear
    if (this._viewType === 'input' && !this._isPromptActive) this.viewInput(this._getTip())
  }

  _initStyles() {
    this.styles = {}
    this.styles.dim = chalk.dim
    this.styles.grey = chalk.grey
    this.styles.gray = chalk.grey
    this.styles.italic = chalk.italic
    this.styles.bold = chalk.bold
    this.styles.underline = chalk.underline
    this.styles.title = chalk.bold.underline
    this.styles.red = chalk.rgb(255, 99, 99)
    this.styles.green = chalk.green
    this.styles.yellow = chalk.yellow
    this.styles.blue = chalk.blue
    this.styles.cyan = chalk.cyan
    this.styles.white = chalk.white
  }

  _initIcons() {
    this.icons = {}
    this.icons.bolt = this.styles.red(emoji.get('zap'))
    this.icons.tick = this.styles.green(figures.tick)
    this.icons.cross = this.styles.red(figures.cross)
    this.icons.warning = this.styles.red(figures.warning)
    this.icons.info = this.styles.red(figures.info)
    this.icons.line = figures.line
    this.icons.arrow = this.styles.red(figures.arrowRight)
    this.icons.arrowDown = figures.arrowDown
    this.icons.pointer = this.styles.red(figures.pointerSmall)
    this.icons.question = this.styles.red('?')
  }

  _canRenderBolt() {
    const { TERM_PROGRAM, TERM } = process.env
    let userTerminalAppName = TERM_PROGRAM || TERM

    const isMac = process.platform === 'darwin'

    const workingTerminals = ['vscode', 'Hyper']

    if (isMac && workingTerminals.includes(userTerminalAppName)) {
      return true
    }

    // we don't really need this list, but I'd like to keep track of them
    const notWorkingTerminals = ['Apple_Terminal', 'MacTerm', 'iTerm.app', 'screen', 'xterm-256color']
    if (notWorkingTerminals.includes(userTerminalAppName)) {
      return false
    }

    return false
  }
}

module.exports = CLI
