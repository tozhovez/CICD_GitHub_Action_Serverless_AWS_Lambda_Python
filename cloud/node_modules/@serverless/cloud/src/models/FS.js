'use strict'

const path = require('path')
const fse = require('fs-extra')
const AdmZip = require('adm-zip')
const download = require('download')
const chokidar = require('chokidar')
const parsePackageJsonName = require('parse-packagejson-name')
const fs = require('fs')
const fg = require('fast-glob')
const debounce = require('debounce')
const spawn = require('child-process-ext/spawn')
const isGitUrl = require('is-git-url')
const downloadRepo = require('download-git-repo')
const axios = require('axios')
const Piscina = require('piscina')
const chunk = require('chunk')
const os = require('os')
const del = require('del')

const cpus = os.cpus()

const defaultIgnored = ['.git/**', '.gitignore', '.serverlessignore', 'node_modules/**']

const defaultExcludes = [
  '.git',
  '.gitignore',
  '.serverlessignore',
  'package-lock.json',
  'node_modules/serverless',
  'node_modules/@serverless/cloud',
  'node_modules/aws-sdk/**/*.d.ts',
  'node_modules/aws-sdk/**/*.examples.json',
  'node_modules/aws-sdk/**/*.md',
  'node_modules/aws-sdk/dist',
  'node_modules/aws-sdk/dist-tools',
  'node_modules/aws-sdk/scripts'
]

const hashingWorker = new Piscina({
  filename: path.resolve(__dirname, '..', 'workers', 'hash.js'),
  concurrentTasksPerWorker: 1
})

class FS {
  constructor(data = {}) {
    this.update(data)
  }

  update(data = {}) {
    this.serviceRoot = data.serviceRoot || this.serviceRoot || process.cwd()
    this.serviceFileName = data.serviceFileName || this.serviceFileName || 'package.json'
    this.serviceFilePath = path.join(this.serviceRoot, this.serviceFileName)
    this.serviceFile = data.serviceFile || this.serviceFile

    this.dataFileName = data.dataFileName || this.dataFileName || 'data.json'
    this.dataFilePath = path.join(this.serviceRoot, this.dataFileName)
    this.dataFile = data.dataFile || this.dataFile

    this.exclude = defaultExcludes.concat(data.exclude || this.exclude || [])
    this.ignored = defaultIgnored

    this.setIgnoredFiles()
  }

  setIgnoredFiles() {
    if (fs.existsSync('.serverlessignore')) {
      const contents = fs.readFileSync('.serverlessignore')
      contents
        .toString('utf8')
        .split(/\r?\n/)
        .forEach((ignore) => {
          if (ignore) {
            this.ignored.push(ignore)
            this.exclude.push(ignore)
          }
        })
    }
  }

  async createServiceDir(serviceName) {
    const serviceRoot = path.resolve(process.cwd(), serviceName)

    if (fs.existsSync(serviceRoot)) {
      throw new Error(`Directory named ${serviceName} already exists.`)
    }

    fs.mkdirSync(serviceRoot)

    this.update({ serviceRoot })
  }

  async read() {
    await Promise.all([this.readServiceFileIfExists(), this.readDataFileIfExists()])
  }

  async emptyDir() {
    del.sync([
      `${this.serviceRoot}/**`,
      `!${this.serviceRoot}`,
      `!${this.serviceRoot}/.git/**`,
      `!${this.serviceRoot}/.gitignore`,
      `!${this.serviceRoot}/.serverlessignore`
    ])
  }

  async isCwdEmpty() {
    const fileNames = fg.sync('**/*', {
      cwd: this.serviceRoot,
      dot: true,
      unique: true,
      ignore: ['.git', '.gitignore', '.serverlessignore']
    })

    if (fileNames.length === 0) {
      return true
    }

    return false
  }

  async readJsonFileIfExists(jsonPath) {
    try {
      return await fse.readJson(jsonPath, { throws: false })
    } catch (e) {
      return null
    }
  }

  async readServiceFileIfExists() {
    const serviceFile = await this.readJsonFileIfExists(this.serviceFilePath)

    if (serviceFile && (await this._isValidServiceFile(serviceFile))) {
      this.serviceFile = serviceFile

      this.defaults = this._parseNameProperty(this.serviceFile.name)
      this.serviceFile.serverless = this.serviceFile.serverless || {}

      return this.serviceFile
    }
  }

  async readDataFileIfExists() {
    this.dataFile = await this.readJsonFileIfExists(this.dataFilePath)
    return this.dataFile
  }

  async readDataFile() {
    this.dataFile = await this.readDataFileIfExists()

    if (!this.dataFile) {
      throw new Error(`Data file "${this.dataFileName}" does not exist in the cwd`)
    }

    return this.dataFile
  }

  async writeServiceFile({ serviceName, orgName } = {}) {
    if (serviceName) {
      this.serviceFile.name = serviceName
      this.serviceFile.serverless.app = serviceName
    }

    if (orgName) {
      this.serviceFile.serverless.org = orgName
    }

    // remove the service property for migration
    if (this.serviceFile.serverless.service) {
      delete this.serviceFile.serverless.service
    }

    await fse.writeJson(this.serviceFilePath, this.serviceFile, { spaces: 2 })
    return this.serviceFile
  }

  async writeDataFile(data) {
    this.dataFile = data || this.dataFile
    await fse.writeJson(this.dataFilePath, this.dataFile, { spaces: 2 })
  }

  _normalizePotentialGitUrl(potentialGitUrl) {
    return potentialGitUrl.endsWith('.git') ? potentialGitUrl : `${potentialGitUrl}.git`
  }

  async initService({ orgName, serviceName, templateName }) {
    await this.emptyDir()
    if (templateName && isGitUrl(this._normalizePotentialGitUrl(templateName))) {
      await this.downloadUserTemplate(this._normalizePotentialGitUrl(templateName))
    } else {
      await this.downloadCoreTemplate(templateName)
    }

    await this.readServiceFileIfExists()
    await this.writeServiceFile({ orgName, serviceName })
    await this.installDependenciesIfExists()
  }

  async listCoreTemplates() {
    const templatesJsonPath = `https://raw.githubusercontent.com/serverless/cloud/main/templates.json`

    return (await axios.get(templatesJsonPath)).data
  }

  async downloadUserTemplate(template) {
    return new Promise((resolve, reject) => {
      downloadRepo(`direct:${template}`, this.serviceRoot, { clone: true }, (error) =>
        error ? reject(error) : resolve()
      )
    })
  }

  async downloadCoreTemplate(templateName = 'default') {
    const githubOrgName = 'serverless'
    const githubRepoName = 'cloud'
    const githubBranchName = 'main'
    const githubDirectoryName = 'templates'
    const githubRepoUrl = `https://github.com/${githubOrgName}/${githubRepoName}/archive/refs/heads/${githubBranchName}.zip`
    const githubExampleFilePrefix = `${githubRepoName}-${githubBranchName}/${githubDirectoryName}/${templateName}/`

    const githubRepoBuffer = await download(githubRepoUrl)
    const githubRepoZip = new AdmZip(githubRepoBuffer)
    const githubRepoZipEntries = githubRepoZip.getEntries()

    const exampleEntries = githubRepoZipEntries.filter((e) => {
      return (
        e.entryName.startsWith(githubExampleFilePrefix) &&
        e.entryName !== githubExampleFilePrefix && // for some reason this is also an entry
        !e.entryName.endsWith('/') // and any dir for that matter
      )
    })

    if (exampleEntries.length === 0) {
      throw new Error(`Template "${templateName}" does not exist`)
    }

    const promises = []
    for (const exampleEntry of exampleEntries) {
      const exampleFileRelativePath = exampleEntry.entryName.replace(githubExampleFilePrefix, '')
      const exampleFileAbsolutePath = path.join(this.serviceRoot, exampleFileRelativePath)
      const exampleFileContent = exampleEntry.getData()

      promises.push(fse.outputFile(exampleFileAbsolutePath, exampleFileContent))
    }

    await Promise.all(promises)
  }

  async installDependenciesIfExists() {
    const dependenciesPropExists =
      this.serviceFile.dependencies && Object.keys(this.serviceFile.dependencies).length !== 0

    const devDependenciesPropExists =
      this.serviceFile.devDependencies && Object.keys(this.serviceFile.devDependencies).length !== 0

    if (dependenciesPropExists || devDependenciesPropExists) {
      await spawn('npm', ['install'], { cwd: this.serviceRoot })
    }
  }

  _parseNameProperty(name) {
    const { scope: org, fullName: app } = parsePackageJsonName(name)
    return { org, app }
  }

  async _isValidServiceFile(serviceFile) {
    const mainFilePath = path.join(this.serviceRoot, serviceFile.main || 'index.js')
    const defaultMainJsFilePath = path.join(this.serviceRoot, 'index.js')
    const defaultMainTsFilePath = path.join(this.serviceRoot, 'index.ts')

    const namePropertyExists = serviceFile.name

    const mainFileExists =
      (await fse.pathExists(mainFilePath)) ||
      (await fse.pathExists(defaultMainJsFilePath)) ||
      (await fse.pathExists(defaultMainTsFilePath))

    if (namePropertyExists && mainFileExists) {
      return true
    }
    return false
  }

  async watch(callback) {
    this.setIgnoredFiles()

    const watcher = chokidar.watch(this.serviceRoot, {
      cwd: this.serviceRoot,
      ignored: this.ignored
    })

    const filePaths = new Set()

    const sync = debounce(
      () => {
        const cloned = new Set(filePaths)
        callback(cloned)
        filePaths.clear()
      },
      50,
      false
    )

    const emit = (filePath) => {
      filePaths.add(filePath)
      sync()
    }

    watcher.on('ready', () => {
      watcher.on('add', emit)
      watcher.on('change', emit)
      watcher.on('unlink', emit)
    })
  }

  glob(src) {
    const fileNames = fg.sync('**/*', {
      cwd: src,
      dot: true,
      unique: true,
      ignore: this.exclude
    })

    return fileNames.map((fileName) => path.resolve(src, fileName))
  }

  hash(filePaths) {
    const taskSize = Math.ceil((filePaths.length + 1) / cpus.length) * 2
    const tasks = chunk(filePaths, taskSize)

    return Promise.all(tasks.map((task) => hashingWorker.run(task)))
  }
}

module.exports = FS
