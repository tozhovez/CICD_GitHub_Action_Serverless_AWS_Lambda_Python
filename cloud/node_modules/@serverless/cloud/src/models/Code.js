'use strict'

const AdmZip = require('adm-zip')
const path = require('path')
const download = require('download')
const normalizePath = require('normalize-path')
const request = require('../utils/request')
const Piscina = require('piscina')

const packagingWorker = new Piscina({
  filename: path.resolve(__dirname, '..', 'workers', 'package.js')
})

const ONE_MINUTE_MS = 60000

class Code {
  constructor(data) {
    this.fs = data.fs
    this.org = data.org
    this.service = data.service
    this.instance = data.instance
    this.analytics = data.analytics

    this.src = this.fs.serviceRoot

    this.previousMapDownloadUrl = null
    this.changesUploadUrl = null
    this.sourceDownloadUrl = null

    this.files = {}
    this.map = {}
    this.previousMap = {}

    this.filesToUpload = []
    this.filesToDelete = []
  }

  timerMs() {
    const start = process.hrtime.bigint()
    return function () {
      const end = process.hrtime.bigint()
      return parseFloat((Number(end - start) / 1000000).toFixed(2))
    }
  }

  async downloadPreviousMap() {
    try {
      this.previousMap = await request({
        method: 'GET',
        url: this.previousMapDownloadUrl
      })
    } catch (e) {
      return null
    }
  }

  async getUrls() {
    // 1000ms
    const options = {
      accessKey: this.org.accessKey,
      method: 'GET',
      endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instance.instanceName}/code`,
      params: {
        instanceType: this.instance.instanceType
      }
    }

    const res = await request(options)

    this.instance.url = res.deployUrls.instanceUrl
    this.previousMapDownloadUrl = res.deployUrls.previousMapDownloadUrl
    this.sourceDownloadUrl = res.deployUrls.sourceDownloadUrl
    this.changesUploadUrl = res.deployUrls.changesUploadUrl
    this.deployToken = res.deployToken
    this.deployTokenExpiration = res.deployTokenExpiration
  }

  async getUrlsAndPreviousMap(operation) {
    const timeToExpire = this.deployTokenExpiration - Date.now()
    if (this.previousMapDownloadUrl && timeToExpire > ONE_MINUTE_MS) {
      return { timeInMs: 0 }
    }
    const getUrlsTimers = this.timerMs()

    await this.getUrls(operation)
    await this.downloadPreviousMap()

    return { timeInMs: getUrlsTimers() }
  }

  async hashFilesAndMap(updatedFilePaths) {
    const start = this.timerMs()

    // sync seems to be faster than async, why?
    // shouldn't we be able to gain some fs concurrency?
    // if so, can we merge in to glob-hash-stat?
    const filePaths = updatedFilePaths ? Array.from(updatedFilePaths) : this.fs.glob(this.src)

    const results = await this.fs.hash(filePaths)

    for (const result of results) {
      for (const { file, hash, mode, size, filePath } of result) {
        const relativePath = normalizePath(path.relative(this.src, filePath))

        if (file) {
          this.map[relativePath] = hash
          this.files[relativePath] = {
            file,
            mode,
            size
          }
        } else {
          delete this.map[relativePath]
          delete this.files[relativePath]
        }
      }
    }

    return { timeInMs: start() }
  }

  getFilesToUpload() {
    const files = Object.keys(this.map)

    this.filesToUpload = files.filter((filePath) => this.previousMap[filePath] !== this.map[filePath])
  }

  getFilesToDelete() {
    const files = Object.keys(this.previousMap)

    this.filesToDelete = files.filter((filePath) => !this.map[filePath])
  }

  hasChanged() {
    this.getFilesToUpload()
    this.getFilesToDelete()

    return this.filesToUpload.length || this.filesToDelete.length
  }

  async zipChanges() {
    const { zipBuffer, previousMap } = await packagingWorker.run({
      files: this.files,
      filesToUpload: this.filesToUpload,
      filesToDelete: this.filesToDelete,
      map: this.map
    })

    this.previousMap = previousMap
    this.zipBuffer = zipBuffer

    return zipBuffer
  }

  async uploadChanges() {
    // 500ms
    await request({
      method: 'PUT',
      url: this.changesUploadUrl,
      body: this.zipBuffer
    })
  }

  async downloadSource() {
    const buffer = await download(this.sourceDownloadUrl)
    const sourceZip = new AdmZip(buffer)

    sourceZip.deleteFile('source.map')
    sourceZip.extractAllTo(this.src)
  }

  async processChanges() {
    const options = {
      accessKey: this.org.accessKey,
      method: 'POST',
      body: {
        deployToken: this.deployToken
      },
      endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instance.instanceName}/code`
    }

    await request(options)
  }

  async init(filePaths) {
    return Promise.all([this.hashFilesAndMap(filePaths), this.getUrlsAndPreviousMap()])
  }

  async deploy() {
    const deployTimes = {
      zip: 0,
      upload: 0,
      processChanges: 0
    }
    if (this.hasChanged()) {
      const endZipTimer = this.timerMs()
      await this.zipChanges()
      deployTimes.zip = endZipTimer()
      const uploadTimer = this.timerMs()
      await this.uploadChanges()
      deployTimes.upload = uploadTimer()
      const processChangesTimer = this.timerMs()
      await this.processChanges()
      deployTimes.processChanges = processChangesTimer()
    }

    return deployTimes
  }

  async sync(filePaths) {
    const syncTimer = this.timerMs()
    const [initFilesRes, getUrlsRes] = await this.init(filePaths)
    const { timeInMs: hashTimeInMs } = initFilesRes
    const { timeInMs: getUrlsTimeMs } = getUrlsRes

    const bytes = Object.values(this.files).reduce((memo, { size }) => memo + size, 0)

    if (bytes > 134217728) {
      // TODO: consider just logging an error and not breaking the shell
      throw new Error('Your code size must not exceed 128MB.')
    }

    if (this.hasChanged()) {
      const deployMetrics = await this.deploy()
      // do not block the CLI with analytics
      this.analytics
        .publish('cloud.dev.synced', {
          serviceName: this.service.serviceName,
          instanceName: this.instance.instanceName,
          fileSizeBytes: bytes,
          syncTimeMs: syncTimer(),
          zipTimeMs: deployMetrics.zip,
          uploadTimeMs: deployMetrics.upload,
          processChangesTimeMs: deployMetrics.processChanges,
          hashTimeMs: hashTimeInMs,
          downloadMapTimeMs: getUrlsTimeMs
        })
        .catch(() => {})
    }
  }
}

module.exports = Code
