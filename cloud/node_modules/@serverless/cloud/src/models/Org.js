'use strict'

const R = require('ramda')
const request = require('../utils/request')
const Service = require('./Service')

class Org {
  constructor(data = {}) {
    this.cloud = data.cloud
    this.user = data.user
    this.accessKey = process.env.SERVERLESS_ACCESS_KEY
    this.orgName = data.orgName
  }

  async getOrgName() {
    this.orgName = this.orgName || (await this.user.getDefaultOrgName())
    return this.orgName
  }

  async getAccessKey() {
    this.accessKey = this.accessKey || (await this.user.getToken())

    return this.accessKey
  }

  async authorize({ activationCode } = {}) {
    await this.getOrgName()
    await this.getAccessKey()

    if (activationCode) {
      await this.activateBetaCode(activationCode)
    }
  }

  async isActivated() {
    if (this.activated === undefined) {
      try {
        await this.activateBetaCode('is-activated')
      } catch (e) {
        this.activated = true
        if (e.message.includes('has already been activated')) {
          return true
        }
      }
      this.activated = false
    }
    return this.activated
  }

  async activateBetaCode(activationCode) {
    if (!this.orgName) {
      throw new Error('Please login using "cloud login" before activating with your access code.')
    }
    const options = {
      accessKey: this.accessKey,
      method: 'POST',
      endpoint: `/orgs/${this.orgName}/activate`,
      body: { code: activationCode }
    }

    await request(options)
  }

  async listServices() {
    const options = {
      accessKey: this.accessKey,
      method: 'GET',
      endpoint: `/orgs/${this.orgName}/services`
    }

    return await request(options)
  }

  async listServicesWithInstances() {
    const services = await this.listServices()

    const servicesWithInstances = await Promise.all(
      services.map(async (s) => {
        const service = new Service({ org: this, serviceName: s.serviceName })
        const serviceInstances = await service.listInstances()

        if (serviceInstances.length === 0) {
          return null
        }

        return s
      })
    )

    return R.reject(R.isNil, servicesWithInstances)
  }

  async isAuthorized() {
    await this.authorize()
    try {
      await this.listServices()
    } catch (e) {
      if (e.message.includes('Your credentials do not have access to the Organization')) {
        return false
      }
    }

    return true
  }

  async getParams() {
    const options = {
      accessKey: this.accessKey,
      method: 'GET',
      endpoint: `/orgs/${this.orgName}/params`
    }

    const { params } = await request(options)

    return params
  }

  async putParams(newParams) {
    const options = {
      accessKey: this.accessKey,
      method: 'PATCH',
      endpoint: `/orgs/${this.orgName}/params`,
      body: { params: newParams }
    }

    const { params } = await request(options)

    return params
  }
}

module.exports = Org
