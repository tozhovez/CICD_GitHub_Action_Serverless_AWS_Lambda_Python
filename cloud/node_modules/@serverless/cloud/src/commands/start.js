'use strict'

const stringifyTimer = require('../utils/stringifyTimer')

const FS = require('../models/FS')
const User = require('../models/User')
const Org = require('../models/Org')
const Service = require('../models/Service')
const Instance = require('../models/Instance')
const Code = require('../models/Code')
const Data = require('../models/Data')
const Analytics = require('../models/Analytics')
const Platform = require('../models/Platform')

const login = require('./login')
const activate = require('./activate')
const init = require('./init')
const outputInstanceLogs = require('../utils/outputInstanceLogs')

module.exports = async (cli) => {
  cli.viewSpinner('Starting')
  const fs = new FS()
  await fs.read()

  let isSeedingEnabled = cli.options.seed || cli.options.s
  const isReseedingEnabled = cli.options.reseed || cli.options.rs
  let orgName

  const loginToken = cli.options.login

  const user = new User()

  if (loginToken) {
    orgName = await user.restoreOrgLogin(loginToken)
    cli.logSuccess('Successfully logged in.')
  }

  if (!user.isLoggedIn()) {
    cli.logInfo('You must login to proceed.')
    await login(cli)
    user.load()
  }

  if (!fs.serviceFile) {
    await init(cli)
    await fs.read()

    // Automatically enable seeding when initializing
    // if the template contains the data file
    if (fs.dataFile) {
      isSeedingEnabled = true
    }
  }

  orgName = orgName || cli.options.org || fs.serviceFile.serverless.org
  let serviceName = cli.options.app || fs.serviceFile.serverless.app

  if (!orgName) {
    orgName = await cli.selectOrg(user)
    fs.writeServiceFile({ orgName })
  }

  const org = new Org({ user, orgName })
  await org.authorize()

  if (!serviceName) {
    serviceName = await cli.promptServiceName(fs.defaults.app)
    fs.writeServiceFile({ serviceName })
  }

  cli.viewSpinner('Loading')

  const instanceName = user.username

  if (!(await org.isActivated())) {
    if (!cli.options.activate) {
      cli.logActivation(orgName)
    }

    await activate(cli)
  }

  cli.viewSpinner('Connecting')

  const service = new Service({ org, serviceName })

  const platform = new Platform({ accessKey: org.accessKey })

  const devModeStart = process.hrtime.bigint()
  const analytics = new Analytics({ org })

  await analytics.publish('cloud.dev.enabled', {})

  cli.onQuit(async () => {
    const devModeEnd = process.hrtime.bigint()
    try {
      await analytics.publish('cloud.dev.ended', {
        timeInSeconds: Number(devModeEnd - devModeStart) / 1000000000 // nano -> seconds
      })
    } catch (err) {
      if (process.env.SLS_DEBUG) {
        console.error(err)
      }
    }
  })

  const instance = new Instance({
    org,
    service,
    instanceName
  })

  const code = new Code({
    fs,
    org,
    service,
    instance,
    analytics
  })

  const data = new Data({
    fs,
    org,
    service,
    instance
  })

  await code.sync()

  platform.on('event', (event) => outputInstanceLogs(cli, event))

  // Establish connection with Serverless Platform
  // todo after websocket connection, any errors does not exit cli session
  // we probably need to manually disconnect from the socket on errors
  await platform.connect({
    orgName: org.orgName,
    appName: service.serviceName,
    instanceName: instance.instanceName
  })

  cli.logSuccess(`Connected to your instance of "${service.serviceName}".`)
  cli.logSuccess('Enabled automatic file syncing and log streaming.')

  if (isReseedingEnabled) {
    cli.logSuccess('Enabled automatic data reseeding')
  }

  cli.logUrl(instance.url)

  cli.viewInput()

  const seed = async () => {
    cli.viewSpinner('Seeding')

    await data.import()

    cli.logSuccess(`Seeded data from "${fs.dataFileName}"`)
    cli.viewInput()
  }

  if (isSeedingEnabled) {
    await seed()
  }

  let inProgress = false
  let isCodeUpdatedLogShown = false
  const queuedFilePaths = new Set()

  // this callback ignores the returned promise
  // meaning it can fire while there are operations in progress
  fs.watch(async (filePaths) => {
    for (const filePath of filePaths) {
      queuedFilePaths.add(filePath)
    }

    if (inProgress) {
      return
    }

    inProgress = true

    while (queuedFilePaths.size > 0) {
      const filePathsToProcess = new Set(queuedFilePaths)

      queuedFilePaths.clear()

      if (filePathsToProcess.has(fs.dataFilePath) && isReseedingEnabled) {
        cli.viewSpinner('Seeding', { timer: true })
        await seed()
      }

      cli.viewSpinner('Updating', { timer: true })
      await code.sync(filePathsToProcess)
    }

    inProgress = false

    if (!isCodeUpdatedLogShown) {
      cli.logSuccess(`Successfully updated your code in ${stringifyTimer(cli.timer)}.`)
      isCodeUpdatedLogShown = true
    }

    cli.viewInput()
  })

  return null
}
